关于ivf_index的使用

```sql
create index idx01 using ivfflat on vector_index_09(b) lists=3 op_type "vector_l2_ops";
```



lists 的作用
lists 是 IVF (Inverted File) 索引的一部分，它定义了向量空间被分割成多少个“簇”或“列表”。向量检索时，算法不会遍历整个数据集，而是首先确定向量最接近的簇（列表），然后只在该簇中进行最近邻搜索。分簇的数量越多，搜索的效率通常越高，因为它减少了搜索的空间。具体来说：

IVF原理：在构建索引时，向量会被分配到不同的簇中。检索时，输入向量会被分配到最接近的簇，算法只需在这个簇内搜索相似的向量，而不是在整个数据集中搜索。
lists 参数的含义：lists=5 表示在索引构建时，向量数据被划分为 5 个簇。这有助于提高检索速度，因为在检索时，只需要访问最相似的几个簇中的数据。
确定输入向量属于哪个簇
对于确定输入向量属于哪个簇（也称为list）的过程，通常采用以下方法：

聚类算法（如k-means）：在构建 IVFFLAT 索引时，通常会使用像 k-means 这样的聚类算法来将向量空间划分为多个簇。每个簇的中心点称为质心（centroid）。构建索引时，每个数据点会分配到与其距离最近的质心所对应的簇中。

检索时的簇分配：在检索过程中，输入的查询向量会首先通过向量距离度量（在此案例中是 L2 欧氏距离）计算出它与各个簇的质心之间的距离。向量会被分配到距离最近的质心所对应的簇，随后在该簇中进行具体的相似度检索。

在您的 SQL 查询中：


```sql
select * from vector_index_01 order by  L2_DISTANCE(b, "[16, 15, 0, 0, 5, 46, 5, 5, 4, 0, 0, 0, 28, 118, 12, 5, 75, 44, 5, 0, 6, 32, 6, 49, 41, 74, 9, 1, 0, 0, 0, 9, 1, 9, 16, 41, 71, 80, 3, 0, 0, 4, 3, 5, 51, 106, 11, 3, 112, 28, 13, 1, 4, 8, 3, 104, 118, 14, 1, 1, 0, 0, 0, 88, 3, 27, 46, 118, 108, 49, 2, 0, 1, 46, 118, 118, 27, 12, 0, 0, 33, 118, 118, 8, 0, 0, 0, 4, 118, 95, 40, 0, 0, 0, 1, 11, 27, 38, 12, 12, 18, 29, 3, 2, 13, 30, 94, 78, 30, 19, 9, 3, 31, 45, 70, 42, 15, 1, 3, 12, 14, 22, 16, 2, 3, 17, 24, 13]") ASC LIMIT 2;
```

这条查询通过 L2_DISTANCE 函数计算向量 b 与查询向量之间的欧氏距离，并按距离从小到大排序，返回最近的两个向量。在检索过程中，系统会首先确定查询向量所属的簇，然后在该簇中进行距离计算。

小结
lists 参数：确定了构建 IVF 索引时，将向量划分为多少个簇。簇的数量越多，检索时访问的数据量越少，查询速度越快。
簇的确定：在检索时，输入向量首先会通过 L2 距离计算被分配到最近的簇，然后在该簇中进一步计算具体的相似度并返回结果。


```
SHOW VARIABLES LIKE 'experimental_ivf_index';

```




### 关于ivf flat hidden table的理解

在 IVFFLAT 索引的设计中，meta、centroids 和 entries 三张表分别用于存储与索引相关的不同类型的数据。每张表的功能和存储内容如下：

1. meta 表
作用：存储索引的元数据信息。
存储的内容：
元数据表中通常会存储有关索引本身的配置和状态信息，比如创建索引时使用的参数、版本号等。
在您的代码片段中，meta 表有两个列：key（主键）和 val（值），这些字段用于存储键值对形式的元数据信息。
key 可能表示某些索引的属性名，val 是相应的属性值。
2. centroids 表
作用：存储 IVFFLAT 索引中向量簇的质心（Centroids）。
存储的内容：
IVFFLAT 索引是基于向量簇的索引结构。在构建索引时，向量空间会通过聚类算法（如 k-means）划分为多个簇，每个簇有一个质心，用于快速搜索相似向量。
centroids 表存储每个簇的质心信息，包括：
version：质心的版本号，用于区分不同版本的索引。
id：质心的唯一标识符。
centroid：实际存储的质心向量（根据列类型为 VECF32 或 VECF64）。
3. entries 表
作用：存储原始数据的映射关系及其对应的向量。
存储的内容：
entries 表存储了原始表中每个数据项与其对应向量的映射关系。每个数据项（或者说每个向量）的信息被分配到特定的簇中。
entries 表的列包括：
version：版本号。
id：与向量相关的 ID，表示该条数据所属的簇。
origin_pk：原始表中的主键，用于关联到原始数据。
entry：实际的向量数据。
这些表的分工使得 IVFFLAT 索引能够有效地执行向量检索操作：

meta 表提供关于索引的元数据支持。
centroids 表加速了簇的查找，每个质心表示一个簇的中心，用于快速定位数据。
entries 表存储了原始向量及其所属簇的信息，从而在检索时快速查找最接近的向量。
总结：
meta 表：存储索引的元数据信息（如配置、版本等）。
centroids 表：存储向量簇的质心信息，用于快速簇查找。
entries 表：存储原始数据的映射关系和对应的向量，用于在检索时找到具体数据。


### 质心数量和list变量的关系


centroids 表的质心数量与 IVF 索引中的 lists 变量直接相关。它们之间的关系可以从 IVFFLAT 索引的工作原理中理解。

IVF 索引中的 lists 参数：
lists 参数定义了向量空间划分的簇（或列表）的数量。在构建 IVF 索引时，向量空间会根据 lists 参数分割为多个簇，每个簇对应一个质心（Centroid）。
这些质心用于加速查询。当执行向量检索时，首先通过计算查询向量与每个质心的距离，将查询向量分配到最接近的质心所对应的簇中，然后在该簇中查找最相似的向量。
centroids 表的质心数量：
在 centroids 表中，每一条记录代表一个簇的质心。
质心的数量 就是 IVF 索引中的 lists 参数的值。也就是说，lists=5 时，IVFFLAT 索引会将向量空间分为 5 个簇，因此 centroids 表中会有 5 条记录，每条记录对应一个簇的质心。
举例说明：
假设我们在构建 IVF 索引时指定了 lists=5，那么：

向量空间会被划分为 5 个簇，每个簇有一个质心。
在 centroids 表中，会有 5 条记录，每一条记录表示一个质心。
检索时，系统会首先计算查询向量与这 5 个质心的距离，并选择距离最近的那个质心，然后在该质心所对应的簇内进行进一步搜索。
总结：
lists 参数确定了簇（质心）的数量。
centroids 表 中的质心数量正是由 lists 参数定义的。


### 质心的确定

质心的 ID 是在构建 IVFFLAT 索引时由聚类算法（通常是 k-means）确定的。每个质心代表一个簇，向量会通过与这些质心的距离被分配到最接近的质心中。在 LLM 索引的设计中，质心 ID 用于表示每个向量（embedding）所属的簇。

1. 质心的 ID 是如何得出的：
在构建 IVFFLAT 索引时，首先会对所有的向量进行聚类，例如通过 k-means 算法将向量空间划分为 lists 个簇（lists=100 表示 100 个质心）。
每个簇有一个质心，质心的 ID 是聚类算法给出的唯一标识，用来表示每个簇。
当一个新的向量（embedding）要插入到索引中时，系统会计算它与所有质心的距离，并将它分配到距离最近的质心（即簇），质心的 ID 就是该向量所属簇的标识。
2. 向已建立的 LLM 索引中继续插入文件时，原有 embedding 的质心会改变吗？
原有 embedding 对应的质心 不会改变，原因如下：

索引构建后的质心是固定的：当你构建 LLM 索引时，聚类过程会生成固定数量的质心（例如 lists=100），这些质心是静态的，一旦建立，它们就不会因为新数据的插入而改变。
新插入的文件向量会根据已有的质心分配：当新文件插入时，新的向量（embedding）会被计算并根据现有的质心（即现有的簇）分配到距离最近的质心中。这个过程不会影响原有的 embedding 对应的质心。
3. 质心和簇的静态性：
质心是静态的：一旦创建了 IVFFLAT 索引并确定了质心（即确定了簇的数量和位置），质心不会随后续的插入操作而改变。
插入时的处理：当新向量插入时，系统会基于现有质心来计算新向量与各个质心的距离，然后将新向量分配到离它最近的质心所对应的簇。原有的向量分配不受影响。
4. 如果需要重新调整质心：
如果你的数据量显著增加，或者数据的分布发生较大变化，现有的质心可能不再适合，你可能需要重新构建索引或重新计算质心。
这通常涉及重新运行聚类算法，生成新的质心，并将所有向量重新分配到新的簇中。然而，这种操作是手动触发的，正常的插入操作不会自动调整质心。
总结：
质心的 ID 是在初始索引构建时由聚类算法确定的，每个质心代表一个簇。
插入新文件后，原有的 embedding 对应的质心 不会改变，新插入的向量会根据现有的质心进行分配。
如果你希望在数据显著变化后重新计算质心，可以手动重新构建索引，但这不会自动发生。

### 语法文件
.y 文件是 Yacc (Yet Another Compiler Compiler) 的语法文件，通常用于定义解析器的语法规则。Yacc 文件包含上下文无关文法和操作代码，用于将输入解析为抽象语法树（AST），供编译器或解释器进一步处理。Yacc 是一种语法生成工具，能够根据语法定义自动生成解析器。

在您的例子中，.y 文件定义了 ALTER TABLE 语句的语法规则。alter_table_alter 是不同 ALTER 操作的解析规则，它描述了如何处理 ALTER TABLE 中的各种操作，如 INDEX、REINDEX、CHECK 和 CONSTRAINT。

如何为 LLM 实现类似 IVFFLAT 的 ALTER 支持
如果您想为 LLM 索引实现类似于 IVFFLAT 在 ALTER TABLE 中的支持，您需要在 Yacc 文件中添加相应的语法规则，并在 AST 构建阶段为 LLM 添加处理逻辑。

步骤概述：
扩展 .y 文件中的语法规则： 您需要为 LLM 添加类似于 IVFFLAT 的语法规则，以便能够解析 ALTER TABLE 语句中的 LLM 索引操作。

例如，在现有规则中添加对 LLM 的支持：
```yacc
| REINDEX ident LLM LISTS equal_opt INTEGRAL
{
    val := int64($6.(int64))
    if val <= 0 {
        yylex.Error("LISTS should be greater than 0")
        return 1
    }
    var keyType = tree.INDEX_TYPE_LLM
    var algoParamList = val
    var name = tree.Identifier($2.Compare())
    $$ = tree.NewAlterOptionAlterReIndex(name, keyType, algoParamList)
}
```

这里的 REINDEX ident LLM LISTS equal_opt INTEGRAL 是 LLM 对 REINDEX 操作的规则解析，类似于 IVFFLAT。

在抽象语法树 (AST) 中增加 LLM 支持：

您需要在 AST 构建过程中增加对 LLM 索引类型的处理。这个过程包括创建新的 AST 节点，并在需要时添加 LLM 索引的处理逻辑。
例如，tree.NewAlterOptionAlterReIndex 方法需要扩展，以支持 INDEX_TYPE_LLM。
在后端实现 LLM 索引的具体操作逻辑：

一旦语法解析器生成了相应的 AST，后端需要能够根据 AST 进行实际的操作。在这里，您可能需要实现 ALTER 对 LLM 索引的支持，比如重新计算 LLM 索引或调整相关的参数（如 LISTS）。