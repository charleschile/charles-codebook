# 新人练习题串讲-乐驰

  

## 一.练习题目

  

### 权限申请

  

[jumper跳板机权限申请](https://avatar.mws.sankuai.com/#/home)

  
  
  

### thrift-try

  

```shell

brew install thrift

thrift -version

```

  

### 下载词表数据

```shell

# 登陆jumper跳板机

ssh lechi@jumper.sankuai.com

  

# 登陆目标机器

ssh set-tx-waimai-a-thrifttest-staging03

  

# 从lechi权限切换到sankuai权限

sudo -iu sankuai

  

```

  
  

### rpc的原理以及实现

如果没有rpc框架，要怎么调用另外一台服务器上的接口呢？

  

rpc的作用:

1. 屏蔽远程调用何本地调用的区别，让我们感觉就是调用项目内的方法

2. 隐藏底层网络通信的复杂性，让我们更专注于业务逻辑

  

RPC常用于业务系统之间的数据交互，需要保证其可靠性，所以RPC一般默认采用TCP来传输

  

网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是肯定没法直接在网络中传输的，需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做“序列化”。

  

调用方持续地把请求参数序列化成二进制后，经过TCP传输给了服务提供方。服务提供方从TCP通道里面收到二进制数据，那如何知道一个请求的数据到哪里结束，是一个什么类型的请求呢？我们把数据格式的约定内容叫做“协议”。大多数的协议会分成两部分，分别是数据头和消息体。数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；消息体主要是请求的业务参数信息和扩展属性等。

  

根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。这个过程叫作“反序列化”。

  
  

### rpc在架构中的位置

  

RPC框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。利用RPC我们不仅可以很方便地将应用架构从“单体”演进成“微服务化”，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。

  

### thrift

thrift是一种提供序列化的协议

  
  

### 倒排索引
inverted index
**一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射**

```
namespace java com.meituan.mdp.sample.thrift  
  
// 6种条件类型用于数值比较  
enum CompareRelationship {  
    // =  
    EQUAL = 0,  
    // >  
    GREATER = 1,  
    // >=  
    GREATER_OR_EQUAL = 2,  
    // <  
    LESS = 3,  
    // <=  
    LESS_OR_EQUAL = 4,  
    // !=  
    NOT_EQUAL = 5  
}  
  
// 关键词score条件比较  
struct FilterCondition {  
    1: required double value,  
    2: required CompareRelationship comRelation  
}  
  
// 查询请求  
struct QueryRequest {  
    1:   
}  
  
  
// 查询响应
```



### dto
data transfer object 数据传输对象，即rpc 接口请求或传输出去的对象，用于展示层与服务层之间的数据传输对象


### 注解

#### @configuration

`@configuration`是配置类的注解，用于标记一个类作为Bean定义的信息源，即用于定义那些需要由Spring容器来管理的bean

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```

在上述代码中，AppConfig类被标记为@Configuration，这意味着它是一个配置类。在这个配置类中，定义了一个myService的bean，当Spring应用启动时，Spring会自动创建myService的实例，并将其注册到Spring的应用上下文中。

@Configuration注解通常用于全局配置类，通过这个注解，开发者可以自定义Bean的创建过程，控制Bean的初始化和销毁。在实际开发中，我们通常会把一些数据库连接、事务管理、业务服务等bean的定义放在一个被@Configuration注解的类中。

@Configuration注解通常与@Bean注解一起使用。@Bean注解用于标记一个方法，该方法返回一个对象，该对象应由Spring管理。@Bean注解的方法应该在被@Configuration注解的类中。



#### @component

1. 标识组件
在Spring框架中，@Component注解是用来标识一个类为Spring框架的组件。当Spring框架看到类上面有@Component注解时，它就会自动的将该类作为一个Bean进行管理。

2. 自动扫描与装配
@Component注解通常与@ComponentScan注解配合使用，@ComponentScan注解会自动扫描指定包下的所有使用了@Component、@Service、@Repository、@Controller等注解的类，并注册为Bean，所以可以自动收集系统中的Spring组件。

3. 依赖注入
当一个类被@Component注解标记后，Spring会自动为该类进行依赖注入。也就是说，Spring会自动的将与该类有依赖关系的其他Bean注入到该类中，这样就可以在该类中直接使用其他Bean。

4. 别名设置
@Component注解还可以设置别名，例如@Component("myBean")，这样在获取Bean的时候可以使用别名来获取。

总的来说，@Component注解的主要作用就是将一个类标识为Spring的组件，让Spring自动管理这个类，包括创建实例、依赖注入等。


#### @service

1. @Service注解的基本作用
@Service注解是Spring框架的一部分，用于标注在业务层组件上，即Service的实现类上。它是一个特殊的@Component注解，可以被Spring容器扫描并自动注册为Bean。这样，当其他组件或者类需要使用到这个Service的时候，Spring就可以通过依赖注入（DI）将其注入。[1]

2. @Service注解的特殊作用
除了基本的自动注册Bean的功能外，@Service注解还有一些特殊的用途。例如，当你在业务逻辑中需要使用事务管理的时候，你可以在@Service标注的类中使用@Transactional注解来声明事务规则。Spring会对使用@Service注解的类进行特殊处理，确保事务管理的正确应用。

3. 结论
总的来说，@Service注解的主要作用是标注业务层组件，让Spring能够扫描并自动注册它们为Bean，同时还可以配合其他注解使用，如@Transactional，以实现特殊的功能，如事务管理。


#### @Autowired
1. 自动装配
@Autowired是Spring框架中的一个注解，其主要功能是实现自动装配。在Spring框架中，我们可以使用@Autowired注解来自动注入依赖的Bean。这意味着我们不需要手动通过XML或Java代码来配置Bean之间的依赖关系，Spring框架会自动为我们完成这一操作[1]。

2. 依赖注入
@Autowired注解是依赖注入（DI）的一种实现方式。依赖注入是一种编程技术，它可以使我们的代码更加松耦合，更易于测试和维护。通过@Autowired注解，我们可以将依赖的Bean注入到需要使用这个Bean的地方，从而避免了手动创建和管理对象的复杂性[2]。

3. 使用方式
@Autowired注解可以应用在字段、构造器、setter方法和配置方法上。当@Autowired注解被应用在字段上时，Spring会在创建Bean时，自动为该字段注入相应的依赖。当@Autowired注解被应用在构造器或者方法上时，Spring会在调用该构造器或者方法时，自动为其参数注入相应的依赖[3]。


#### @PostConstruct

1. 初始化方法的标识

@PostConstruct注解是Java EE 5规范中定义的一种标准注解，它用于标识在依赖关系注入完成后，应当执行的初始化方法。这个注解的方法将会在所有的依赖注入操作完成后，且在类实例被首次使用前执行[1]。

2. 生命周期管理

@PostConstruct注解提供了一种生命周期管理的机制。在Spring框架中，Bean的生命周期由Spring容器来管理。当一个Bean被实例化和初始化后，Spring容器会调用被@PostConstruct注解的方法，这样，我们可以在这个方法中执行一些初始化操作，如资源的加载、数据的预处理等[2]。

3. 使用方式

@PostConstruct注解应用在方法上。这个方法不能带有任何参数，也不应该有返回值（即返回类型为void）。此外，这个方法应该不抛出已检查异常。这个方法的访问级别没有限制，可以是public、protected、package-private（默认）或private





### java

#### ObjectMapper

ObjectMapper是com.fasterxml.jackson.databind包中的一个类，它提供了一种简单的方法来将Java对象转换为JSON对象，以及将JSON字符串转换为Java对象。

ObjectMapper的常用方法:
- writeValueAsString(Object obj): 将Java对象转换为JSON字符串。
- readValue(): 将JSON字符串转换为Java对象
```java
public void objectMapperTest() throws JsonProcessingException {
        // 创建ObjectMapper对象
        ObjectMapper mapper = new ObjectMapper();
        
        // 创建一个Java对象
        SpuNode spuNode = new SpuNode();
        spuNode.setSpuId(1);
        spuNode.setScore(1.0);

        // 使用writeValueAsString()方法将Java对象转换为JSON字符串
        String jsonString = mapper.writeValueAsString(spuNode);
        System.out.println("转换后的JSON字符串: " + jsonString);

        // 使用readValue()方法将JSON字符串转换为Java对象
        SpuNode spuNode2 = mapper.readValue(jsonString, SpuNode.class);
        System.out.println("转换后的Java对象: " + spuNode2.getSpuId() + ", " + spuNode2.getScore());
    } 
```


```shell
转换后的JSON字符串: {"spuId":1,"score":1.0}
转换后的Java对象: 1, 1.0
```



lion是配置管理

### 代码解释

文件路径FILE_PATH
数据绑定映射器MAPPER
关键词映射keywordsMap
缓存cache
缓存开关cacheSwitch

初始化方法initialize
SPU信息查询方法spuInfoQuery
左索引搜索方法searchLeftIndex
数据刷新方法flushData
解析方法parse
一些getter和setter方法


initialize()在类实例化后自动执行，用于初始化关键词映射`keywordsMap`: 首先调用`parse`方法解析文件中的数据，然后将解析得到的数据存储在`keywordsMap`中

spuInfoQuery()：用于查询SPU信息。首先，判断关键词映射keywordsMap是否包含给定的关键词，如果不包含，则返回一个空的SpuInfoDTO对象。然后，判断缓存开关是否打开，如果打开，则从缓存中获取数据。接着，根据给定的条件从关键词映射中获取SPU信息，并将获取的信息存储到SpuInfoDTO对象中。最后，返回SpuInfoDTO对象。

searchLeftIndex()方法: 此方法用于搜索给定分数在SPU信息列表中的左索引。使用二分搜索法进行搜索。

flushData()方法: 此方法用于刷新内存中的词表数据。首先，调用parse方法解析文件中的数据，然后将解析得到的数据存储到关键词映射keywordsMap中。

parse()方法: 此方法用于解析文件中的数据。首先，创建一个新的HashMap对象，然后从文件中读取每一行数据，并将每一行数据解析成一个Map<String, Spu>对象。接着，遍历这个Map对象，并将解析得到的数据存储到新创建的HashMap对象中。最后，返回这个HashMap对象。


数据绑定和对象映射：这段代码的数据绑定和对象映射主要体现在使用MAPPER.readValue方法将读取的每一行数据解析成Map<String, Spu>对象，以及后续根据解析出的数据创建新的SpuInfo对象的过程。这两个过程都是将原始数据转换成特定类型的对象，以便于后续的处理和使用。

```java
package com.sankuai.ad.shenqinghui_test.starter.service;

import com.dianping.lion.client.spring.LionConfig;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.meituan.mdp.boot.starter.mdpcache.core.Cache;
import com.sankuai.ad.shenqinghui_test.starter.config.Constants;
import com.sankuai.ad.shenqinghui_test.starter.entity.DTO.SpuInfoDTO;
import com.sankuai.ad.shenqinghui_test.starter.entity.VO.Spu;
import com.sankuai.ad.shenqinghui_test.starter.entity.VO.SpuInfo;
import com.sankuai.ad.shenqinghui_test.thrift.Condition;
import com.sankuai.ad.shenqinghui_test.thrift.RelationCompare;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.MapUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Slf4j
@Component
public class SpuDocParser {

    /**
     * 文件路径
     */
    @LionConfig("com.sankuai.waimai.d.thrifttest.filePath")
    private String FILE_PATH = "/Users/shenqinghui/data/keywords.txt";

    /**
     * databind mapper
     */
    private static ObjectMapper MAPPER = new ObjectMapper();

    /**
     * map size
     */
    private static final int MAP_SIZE = 200000;

    private ConcurrentHashMap<String, List<SpuInfo>> keywordsMap = null;

    /**
     * 本地缓存
     */
    @Autowired
    private Cache cache;

    /**
     * 缓存开关
     * 从Lion获取配置，同时监听配置变更
     */
    @LionConfig("com.sankuai.waimai.d.thrifttest.cacheSwitch")
    private boolean cacheSwitch = false;

    @PostConstruct
    public void initialize() {
        log.info("initialize start");
        long start = System.currentTimeMillis();
        Map<String, Set<SpuInfo>> map = parse();
        if (MapUtils.isEmpty(map)) {
            return;
        }
        keywordsMap = new ConcurrentHashMap<>(map.size());
        map.forEach((key, value) -> {
            List<SpuInfo> spuInfos = new ArrayList<>(value);
            spuInfos.sort(Comparator.comparingDouble(SpuInfo::getScore));
            keywordsMap.put(key, spuInfos);
        });
        log.info("initialize end, consume time:{} ms", System.currentTimeMillis() - start);
    }

    /**
     * 查询SPU信息
     * @param keyword
     * @param condition
     * @return
     */
    public SpuInfoDTO spuInfoQuery(String keyword, Condition condition) {
        SpuInfoDTO spuInfoDTO = new SpuInfoDTO();
        if (Objects.isNull(keywordsMap) || !keywordsMap.containsKey(keyword)) {
            return spuInfoDTO;
        }
//        log.info("cacheSwitch:" + cacheSwitch);
        // 判断缓存开关是否打开
        if (cacheSwitch) {
            List<Integer> cacheIds = null;
            if (Objects.isNull(condition)) {
                cacheIds = cache.get(keyword, List.class);
                if (Objects.nonNull(cacheIds)) {
                    spuInfoDTO.setSpuIds(cacheIds);
                    return spuInfoDTO;
                }
            } else {
                cacheIds = cache.get(keyword +
                        Constants.separator + condition.getRelation().toString() +
                        Constants.separator + condition.getValue(), List.class);
                if (Objects.nonNull(cacheIds)) {
                    spuInfoDTO.setSpuIds(cacheIds);
                    return spuInfoDTO;
                }
            }
        }
        List<SpuInfo> spuInfos = keywordsMap.get(keyword);
        if (CollectionUtils.isNotEmpty(spuInfos)) {
            List<Integer> ids = null;
            if (Objects.isNull(condition)) {
                ids = spuInfos.stream().map(SpuInfo::getSpuId)
                                       .distinct()
                                       .collect(Collectors.toList());
                spuInfoDTO.setSpuIds(ids);
                // 判断缓存开关是否打开
                if (cacheSwitch) {
                    cache.put(keyword, ids);
                }
                return spuInfoDTO;
            }
            double value = condition.getValue();
            int index = searchLeftIndex(spuInfos, value);
            ids = new ArrayList<>(spuInfos.size() - index);
            RelationCompare relation = condition.getRelation();
            switch (relation.getValue()) {
                case 1:
                    for (int i = 0; i < index; i++) {
                        ids.add(spuInfos.get(i).getSpuId());
                    }
                    break;
                case 2:
                    for (int i = index; i < spuInfos.size(); i++) {
                        if (spuInfos.get(i).getScore() > value) {
                            break;
                        }
                        ids.add(spuInfos.get(i).getSpuId());
                    }
                    break;
                case 3:
                    for (int i = index; i < spuInfos.size(); i++) {
                        if (spuInfos.get(i).getScore() == value) {
                            continue;
                        }
                        ids.add(spuInfos.get(i).getSpuId());
                    }
                    break;
                case 4:
                    for (int i = 0; i <= index; i++) {
                        if (i == index && spuInfos.get(i).getScore() > value) {
                            continue;
                        }
                        ids.add(spuInfos.get(i).getSpuId());
                    }
                    break;
                case 5:
                    for (int i = index; i < spuInfos.size(); i++) {
                        ids.add(spuInfos.get(i).getSpuId());
                    }
                    break;
                default:
                    ids = new ArrayList<>();
            }
            ids = ids.stream().distinct().collect(Collectors.toList());
            // 判断缓存开关是否打开
            if (cacheSwitch) {
                cache.put(keyword + Constants.separator + condition.getRelation().toString()
                                                        + Constants.separator + condition.getValue(), ids);
            }
            spuInfoDTO.setSpuIds(ids);
        }
        return spuInfoDTO;
    }

    private int searchLeftIndex(List<SpuInfo> spuInfos, double score) {
        int size = spuInfos.size();
        if (score > spuInfos.get(size - 1).getScore()) {
            return spuInfos.size();
        }
        int left = 0;
        int right = size;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (spuInfos.get(mid).getScore() >= score) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    /**
     * 刷新内存词表数据
     * 1、此处无须考虑加锁，不存在并发问题
     * 2、如果考虑缓存，需要每次更新后，将缓存数据删除?
     */
    public void flushData() {
        log.info("flush start");
        long start = System.currentTimeMillis();
        Map<String, Set<SpuInfo>> map = parse();
        if (MapUtils.isEmpty(map)) { // 如果文件更新有问题，记录日志
            log.error("flush data error");
            return;
        }
        if (Objects.isNull(keywordsMap)) {
            keywordsMap = new ConcurrentHashMap<>(map.size());
        } else {
            keywordsMap.clear();
        }
        map.forEach((key, value) -> {
            List<SpuInfo> spuInfos = new ArrayList<>(value);
            spuInfos.sort(Comparator.comparingDouble(SpuInfo::getScore));
            keywordsMap.put(key, spuInfos);
        });
        log.info("flush end, consume time:{} ms", System.currentTimeMillis() - start);
    }

    private Map<String, Set<SpuInfo>> parse() {
        try {
            Map<String, Set<SpuInfo>> map = new HashMap<>(MAP_SIZE);
            BufferedReader reader = new BufferedReader(new FileReader(FILE_PATH));
            String line = null;
            while ((line = reader.readLine()) != null) {
                Map<String, Spu> spuInfoMap = MAPPER.readValue(line, new TypeReference<Map<String, Spu>>() {});
                for (Map.Entry<String, Spu> entry : spuInfoMap.entrySet()) {
                    String spuId = entry.getKey();
                    Map<String, SpuInfo> keywordMap = entry.getValue().getKwScorePos();
                    for (Map.Entry<String, SpuInfo> keywordEntry : keywordMap.entrySet()) {
                        String keyword = keywordEntry.getKey();
                        SpuInfo value = keywordEntry.getValue();
                        SpuInfo spuInfo = new SpuInfo();
                        spuInfo.setSpuId(Integer.parseInt(spuId));
                        spuInfo.setScore(value.getScore());
                        Set<SpuInfo> spuInfoSet = map.get(keyword);
                        if (spuInfoSet == null) {
                            spuInfoSet = new HashSet<>();
                            spuInfoSet.add(spuInfo);
                            map.put(keyword, spuInfoSet);
                        } else {
                            spuInfoSet.add(spuInfo);
                        }
                    }
                }
            }
            reader.close();
            return map;
        } catch (IOException e) {
            log.error("IOException::", e);
        }
        return null;
    }

    public String getFILE_PATH() {
        return FILE_PATH;
    }

    public void setFILE_PATH(String FILE_PATH) {
        this.FILE_PATH = FILE_PATH;
    }

    public boolean isCacheSwitch() {
        return cacheSwitch;
    }

    public void setCacheSwitch(boolean cacheSwitch) {
        this.cacheSwitch = cacheSwitch;
    }
}
```


### 刘锦成问题


十多个：


引入缓存之后，降了不多，范围查询降了不多-gc碎片
退化成kv查询了
18.9-》20.6
词表加载引发抖动优化思路-〉覆盖方法
判断分支太多了不好
meituan idekit
词表数据结构分析之后对我有什么作用设计、代码，关键字

索引还有其他的组织方式
黑鸭-》黑鸭鸭掌-〉关键词包含+模糊查询

调gc线程数有什么其他副作用，gc调优，gc thread调优的副作用

火焰图各种颜色长度宽度的各种含义，红色？绿色？宽度？参考量？火焰图原理是什么？
缓存是有过期的吗


C++为什么快？靠近底层？jvm？


58的人的作业，索引是？

压测申请机器
线上主要看99和999
99%在5ms

rpc协议thrift

一般都是自己存内存里面

#### loading cache
或者加个锁





### 文件io

fileinputstream是读取文件的二进制原始字节流，比如JPEG原始文件`FF D8 FF E0 00 10 4A 46 49 46 00 01 01 00 00 01 00 01 00 00 ...

inputstreamreader是将输入的字节流转换成字符流，是字节流通向字符流的桥梁，它使用指定的charset读取字节并将其解码为字符`Hello, World!`