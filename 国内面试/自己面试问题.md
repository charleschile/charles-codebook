**延迟双删**

## 腾讯外包（问题搞定）

为什么使用redis，存储了哪些东西

为什么使用springboot

延迟双删

缓存失效策略是什么样的

redis数据类型

缓存穿透

布隆过滤器是怎么样

数据一致性是怎么保证的

jwt介绍一下

### http的没有状态的含义

HTTP（超文本传输协议）被设计为一种无状态的协议，这意味着每次HTTP请求之间是相互独立的。服务器处理完一个请求后，不会保留任何数据（状态）来影响它之后的请求。这种设计有以下几个关键点帮助理解：

1. **独立性**: 每次请求都包含了执行操作所需的所有信息。服务器不依赖之前的请求或响应来处理当前的请求。这意味着如果一个用户请求一个网页，然后请求该网页上的图像，服务器不会“记得”这个用户刚刚请求过网页——每个请求都是独立的。
    
2. **无记忆性**: 由于HTTP是无状态的，服务器不会保存任何关于客户端请求的状态信息。这使得协议简单，易于扩展，并能够处理大量并发连接。
    
3. **会话管理**: 虽然HTTP本身是无状态的，但我们仍然需要在多个请求之间维护状态（例如，确保用户在网站上登录后仍然登录）。为了解决这个问题，引入了会话管理技术，如Cookies、Token或会话存储，这些技术允许服务器“记住”用户的状态，从而在技术层面上实现“有状态”的行为。
    
4. **性能和可伸缩性**: 无状态协议简化了服务器设计，因为服务器不需要保存状态信息，或在服务器重启后恢复状态信息。这降低了服务器的资源消耗，并提高了处理请求的速度，从而有助于提高性能和可伸缩性。
    
5. **应用场景**: HTTP的无状态设计非常适合于Web浏览，其中每个页面的加载可以被视为独立的请求。然而，对于需要持续跟踪用户状态的应用（如在线购物车），则需要额外的机制（如Cookies）来维持状态。
    

总结来说，HTTP无状态的设计是它能够高效、可靠地处理大量并发请求的关键因素之一。虽然这种设计在某些情况下带来了挑战（特别是需要跨请求维护状态的场景），但通过使用Cookies、会话存储和其他技术，可以在无状态的HTTP协议之上构建复杂且功能丰富的Web应用程序。

### session和cookie

### jwt有哪些算法

### 输入url网页的过程网页发生了什么

### 四层网络模型

### websocket

### nginx负载均衡算法

### 正向代理和反向代理

### mysql acid

### 线程安全怎么理解

### java中线程安全怎么实现

### hashmap是线程安全的吗，应该用什么

### springboot为什么要用

## 饿了么（问题搞定）

乐观锁的实现机制

死锁的原理

预防死锁的方法（有哪些，四个原则）

java中检测死锁的方法

**解除死锁的方法**

- 死锁是指两个或多个进程在争夺系统资源时，由于互相等待对⽅释放资源⽽⽆法继续执⾏的状态。
    
- 死锁只有同时满⾜以下四个条件才会发⽣：
    
- 互斥条件：⼀个进程占⽤了某个资源时，其他进程⽆法同时占⽤该资源。
    
- 请求保持条件：⼀个线程因为请求资源⽽阻塞的时候，不会释放⾃⼰的资源。
    
- 不可剥夺条件：资源不能被强制性地从⼀个进程中剥夺，只能由持有者⾃愿释放。
    
- 环路等待条件：多个进程之间形成⼀个循环等待资源的链，每个进程都在等待下⼀个进程所占有 的资源。
    

只需要破坏上⾯⼀个条件就可以破坏死锁。 破坏请求与保持条件：⼀次性申请所有的资源。

破坏不可剥夺条件：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放 它占有的资源。

破坏循环等待条件：靠按序申请资源来预防。让所有进程按照相同的顺序请求资源，释放资源则反序释放。

一个线程需要同时获取多把锁，这时就容易发生死锁

> 例如：
> 
> t1 线程获得A对象锁，接下来想获取B对象的锁
> 
> t2 线程获得B对象锁，接下来想获取A对象的锁

redis为什么用

**redis速度是怎么测的，为什么变快了**

**qps是怎么设置的**

**缓存穿透**

商品越来越多，布隆过滤器造成的内存压力怎么办

最大商品id的最大位数是多少

**延迟双删**

删除商品的话，布隆过滤器应该怎么操作

缓存穿透在删除商品之后怎么解决

redis和java是怎么通信的

**redis的分布式部署**

一段时间内的访问量，redis压力大该怎么办

消息队列了解吗

## 4月1日腾讯二面

### 1. 重入锁和非重入锁

重入锁就是同一个线程可以多次获取同一个锁

比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。

可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。

Java中的`ReentrantLock`类和`synchronized`关键字都是实现重入锁的机制。`ReentrantLock`提供了比`synchronized`更丰富的锁操作，它能够提供诸如尝试锁定（tryLock）、定时锁定（tryLock with timeout）以及公平锁（Fairness）等高级功能。

- **可重入性**：同一个线程可以多次获取同一个锁。
    
- **公平性（可选）**：可以设置锁的公平性，公平锁意味着等待时间最长的线程会首先获得锁。
    
- **锁绑定多个条件**：一个`ReentrantLock`对象可以同时绑定多个`Condition`对象。
    

非重入锁在java编程中大部分情况下不使用

### 2. 公平锁和非公平锁

在Java中，锁（Lock）分为公平锁和非公平锁，这个分类依据是线程获取锁的顺序。这两种锁在处理同步问题时有不同的策略和性能表现。

公平锁是指多个线程按照申请锁的顺序来获取锁。也就是说，第一个请求锁的线程将会成为第一个获得锁的线程，其他线程将会按照请求顺序来获得锁。这种方式确保了没有线程会饿死（也就是说，每个尝试获取锁的线程最终都将获得锁），但可能会导致更长的等待时间，因为每次都是按顺序分配锁。

在Java的`ReentrantLock`类中，可以通过传递`true`给构造函数来创建一个公平锁。例如：

 ReentrantLock fairLock = new ReentrantLock(true);

公平锁的优点是等待锁的线程不会饿死，保证了系统的有序运行。然而，公平锁通常会比非公平锁有更低的吞吐量，因为维护线程顺序会带来更大的开销。

`ReentrantLock`允许你构建公平锁（fair locks），这意味着等待时间最长的线程会优先获取锁。而`synchronized`不保证任何公平性，完全依赖于JVM的调度和实现。

使用`ReentrantLock`时，等待的线程可以被中断（通过调用线程的`interrupt()`方法）。这对于避免死锁非常有用。与此相比，如果一个线程在等待进入`synchronized`同步的方法或代码块，那么它不能被中断。

非公平锁是指线程获取锁的顺序并不按照申请锁的顺序来分配，也就是说，请求锁的线程可以插队。这种方式不保证等待的线程能够按照申请锁的顺序获得锁，有可能某些线程会被饿死。但是，非公平锁的吞吐量一般高于公平锁，因为它减少了线程之间上下文切换的次数。

`ReentrantLock`的默认行为是创建一个非公平锁，可以通过传递`false`给构造函数或者不传递任何参数来创建一个非公平锁。例如：

 ReentrantLock nonFairLock = new ReentrantLock(); // 或者 new ReentrantLock(false);

非公平锁的主要优点是性能较高，因为它减少了排队等待的时间和上下文切换的频率。然而，它的缺点是不能保证所有请求锁的线程都能及时获取锁，可能导致某些线程饿死，从而影响系统的公平性和稳定性

### 3. 索引建立的原则以及索引建立的坑点

1. 高频查询
    
2. 排序和分组
    
3. 外键
    
4. 唯一性验证
    
5. 范围查询
    

坑点：

1. 变动频繁的字段不适合创建索引
    
2. 低基数字段不适合创建索引，就是字段中不同值比例非常低的情况（性别）
    
3. 大型文本段也不适合，一般用搜索引擎来优化
    

### 4. 什么是数据库的外键

数据库的外键（Foreign Key）是一个或多个字段，它在一个表中用于引用另一个表的主键（Primary Key）字段。外键用于建立和维护两个数据库表之间的关系，确保数据的一致性和完整性。通过使用外键，数据库能够强制执行参照完整性（Referential Integrity），这意味着你不能在外键列中添加一个值，除非该值在被引用的表的主键列中已经存在。

- **维护数据一致性和完整性**：通过确保一个表中的字段值必须在另一个表的关键字段中存在，外键帮助维护数据库中数据的逻辑一致性。
    
- **定义表之间的关系**：外键定义了数据库表之间的依赖关系，通常用于表示“一对多”（one-to-many）或“多对一”（many-to-one）关系。例如，一个订单详情表（OrderDetails）可能使用外键引用一个订单表（Orders），表明每个订单详情属于一个特定的订单。
    
- **支持联结查询**：外键使得可以更方便地通过SQL JOIN操作联结相关表，以进行复杂的查询和报告。
    
- **级联操作**：数据库管理系统（DBMS）通常允许定义外键时指定级联操作，如级联更新（Cascade Update）和级联删除（Cascade Delete）。这意味着当被引用表的主键值改变（更新或删除）时，可以自动更新或删除引用这个主键的所有外键值，从而保持数据一致性。
    

#### 例子

假设有两个表：一个是`Employees`表，另一个是`Departments`表。`Departments`表有`DepartmentID`（部门ID）作为主键，而`Employees`表中有一个字段`DeptID`用来指明每个员工所属的部门。

在这种情况下，`Employees`表中的`DeptID`字段就是一个外键，它引用了`Departments`表中的`DepartmentID`字段。这个外键约束确保了在`Employees`表中不能为`DeptID`指定一个不存在于`Departments`表中的`DepartmentID`值。

通过这种方式，外键帮助维护了员工与部门之间的逻辑关系，确保了数据库中的数据一致性和完整性。

### 5. 主键索引和唯一索引的区别

主键索引：

- **唯一性**：主键索引保证了表中每一行的唯一性。这意味着主键字段中的每个值都必须是唯一的。
    
- **非空约束**：主键字段不能包含NULL值。
    
- **表级别唯一性**：每个表只能有一个主键。主键可以由单个列组成，也可以由多个列的组合（复合主键）组成。
    
- **自动创建索引**：当你定义一个列为主键时，数据库自动为该列创建一个主键索引。
    

唯一索引：

- **唯一性**：唯一索引保证了索引列中的每个值都是唯一的，但与主键不同，唯一索引允许有空值（NULL），具体取决于数据库的实现。在许多数据库系统中，唯一索引允许多个NULL值，因为NULL被认为是未知的，且互不相等。
    
- **非表级别唯一性**：一个表可以有多个唯一索引。
    
- **手动创建**：唯一索引不会自动创建。开发者或数据库管理员需要显式定义唯一索引。
    
- **灵活性**：唯一索引提供了额外的灵活性，因为你可以在不违反主键约束的情况下，对任意数量的列添加唯一性约束。
    

主要区别：

- **存在的约束**：主键是一个强制性的表级约束，要求非空和唯一。而唯一索引主要是为了保证数据的唯一性，但可以包含空值。
    
- **数量限制**：每个表只能有一个主键，但可以有多个唯一索引。
    
- **作用和用途**：主键的主要目的是标识表中的每一行，而唯一索引用于防止列中的重复值，为查询提供优化，并可以用于实现业务逻辑上的约束（例如，确保电子邮件地址或用户名的唯一性）。
    

### 6. sql注入了解吗

原理：应用程序没有正确地过滤用户的输入，直接将输入拼接到SQL查询中时，就可能发生SQL注入。攻击者可以通过在预期输入中嵌入SQL命令，来改变原有的SQL查询语句，从而执行未授权的数据库命令。

一个简单的例子是，如果一个网站的登录表单直接将用户输入拼接到SQL查询中，如下所示：

 SELECT * FROM users WHERE username = '$username' AND password = '$password'

如果攻击者在用户名或密码字段中输入 `admin' --`，则SQL查询变为：

 SELECT * FROM users WHERE username = 'admin' --' AND password = '$password'

这里，`--` 是SQL中的注释符号，会使后面的查询部分被注释掉，导致不论密码是什么，查询都会被执行。如果`admin`用户存在，攻击者将无需密码即可登录。

防范方法：

1. **使用预处理语句（Prepared Statements）**：通过使用参数化查询，可以确保接收到的输入被当作数据处理，而不是SQL代码的一部分。
    

 String username = request.getParameter("username");  
 String password = request.getParameter("password");  
 ​  
 String sql = "SELECT * FROM users WHERE username = ? AND password = ?";  
 ​  
 PreparedStatement preparedStatement = connection.prepareStatement(sql);  
 preparedStatement.setString(1, username);  
 preparedStatement.setString(2, password);  
 ​  
 ResultSet resultSet = preparedStatement.executeQuery();  
 ​

在这个改进后的例子中，我们首先使用带有参数占位符（`?`）的SQL查询字符串创建了一个`PreparedStatement`对象。然后，我们使用`preparedStatement.setString`方法为每个占位符设置实际的参数值。这样，无论用户输入什么，它都将被数据库处理为一个普通的字符串值，而不是SQL命令的一部分，从而有效防止了SQL注入攻击。

2. **使用ORM框架**：许多现代的ORM（对象关系映射）框架自动处理参数化查询和转义，减少了SQL注入的风险。
    

java中比较常用的是MyBatis，MyBatis是一个半ORM的框架，它允许开发者通过XML配置文件或注解来指定SQL语句，同时提供参数绑定的功能，从而避免SQL注入。虽然MyBatis给予了开发者编写原生SQL的能力，但通过其提供的参数化查询和动态SQL支持，可以安全地构建查询，避免SQL注入的风险。

### 7. 用数据库的隔离级别

### 8. AOF和RDB哪个快

**RDB（Redis Database）**

- RDB持久化通过创建内存数据的快照来工作，在指定的时间间隔内执行。
    
- RDB是一个非常紧凑（compact）的文件，因为它仅仅存储了Redis在某一时刻的数据快照。
    
- RDB文件通常较小，因为它是经过压缩的，并且不包含任何冗余的操作指令。
    
- 快速恢复大数据集。
    

**AOF（Append Only File）**

- AOF持久化通过记录每个写操作到一个日志文件中来工作，操作以Redis命令的形式追加存储。
    
- 随着时间的推移，由于存储了大量的写操作，AOF文件的大小通常会增长得比RDB文件大很多。
    
- AOF提供了更好的数据安全性，因为它可以配置为每次写操作后都同步到磁盘，或者每秒同步一次。
    
- AOF文件可以通过重写（rewrite）操作来减小文件大小，这个操作会读取当前数据库状态，然后用最少的命令集合创建一个新的AOF文件。即使如此，AOF文件的体积一般仍旧大于RDB文件。
    

### 9. 缩小AOF文件体积的办法

缩小Redis的AOF（Append Only File）文件体积主要通过AOF重写（rewrite）过程来实现。AOF重写并不是对原始AOF文件进行编辑或压缩，而是通过读取当前数据库中的键值对状态来创建一个新的、更小的AOF文件。

。新的AOF文件包含恢复当前数据库状态所需的最小命令集。这个过程可以显著减少AOF文件的大小，特别是在AOF文件中包含了大量已经被覆盖或删除的数据的情况下。

1. **手动触发**：可以通过执行`BGREWRITEAOF`命令来手动启动AOF重写过程。这个命令会在后台启动重写过程，不会阻塞当前的客户端命令。
    
     BGREWRITEAOF
    
2. **自动触发**：Redis允许配置自动触发AOF重写的条件。这些条件可以在Redis配置文件中设置（通常是redis.conf），或通过运行时配置指令动态设置。自动触发重写的条件主要基于文件的增长率和大小。例如，可以设置当AOF文件增长到一定大小，或比上次重写后的大小增长了一定百分比时自动触发重写。
    

### 10. HTTP和HTTPS的区别

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
    
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
    
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
    
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
    

### 11. 数据库连接池

数据库连接池是一种数据库连接缓存技术，当应用程序需要访问数据库时，可以从池中获取一个已经创建的连接，使用完毕后再将其返回到池中，而不是每次需要与数据库交互时都创建和销毁连接。这种方式显著提高了数据库操作的效率，减少了数据库连接时间，也减轻了数据库的负载。

数据库连接池的核心优点包括：

- **减少连接开销**：通过重用现有连接，减少数据库连接和断开连接的频繁操作，降低系统开销。
    
- **提高资源利用率**：连接池管理数据库连接，避免了数据库连接的滥用，确保数据库资源的合理分配。
    
- **提高应用性能**：减少了连接数据库所需的时间，提高了应用程序的响应速度。
    

druid连接池ssm框架中经常学

在Java的SSM（Spring + Spring MVC + MyBatis）框架中，当使用数据库连接池技术时，**实际上是采用的长连接策略**。这意味着一旦数据库连接被建立，它就会保持打开状态，直到被显式关闭，或者根据连接池的配置策略（如空闲超时）被自动关闭。这些连接会被重用，供后续的数据库请求使用，从而避免了频繁地建立和断开连接的开销。

- **性能优化**：由于建立数据库连接是一个开销较大的操作（涉及网络通信、身份验证等过程），使用长连接可以显著减少这部分开销，提高应用性能。
    
- **资源复用**：连接池中的连接在完成一个请求处理后不会立即关闭，而是可以被后续的请求重用。这样，对数据库的访问请求可以快速获取到已经存在的数据库连接。
    
- **连接管理**：数据库连接池负责管理连接的生命周期，包括创建连接、连接复用、连接的定期检查（保证连接的有效性）、以及超时连接的关闭等。这样的管理机制保证了连接资源的高效使用和应用的高性能。
    

- **配置连接池大小**：开发者可以根据应用需求和数据库服务器的能力配置连接池的大小，即同时打开的长连接数量。这有助于平衡性能和资源使用。
    
- **空闲连接处理**：连接池通常提供配置选项，以定期检查并关闭长时间未使用的连接，释放资源。
    
- **连接健康检查**：为了确保从连接池获取的连接是健康可用的，连接池可能会实施定期检查或在实际使用前进行测试。
    

### 三次握手和四次挥手，为什么是三次和四次

### 为什么是四次

### timeawait状态，没有收到怎么办

### DDOS攻击

### 进程、线程、协程的区别

进程是资源分配的最小单位，每个进程都有自己的独立内存空间，进程由进程控制块、程序段和数据段组成。

进程控制块（PCB）保存进程运行期间相关的数据，是进程存在的唯一标志。 程序段是能被进程调度程序调度到CPU 运行的程序的代码段。 数据段用来存储程序运行期间的相关数据。

进程是应用程序运行的载体，可看做是正在执行的程序。程序本身是没有生命周期的，只是存在于磁盘上的一些指令集合，但程序一旦被运行起来就是进程。启动后的进程，会依赖操作系统的调度完成生命周期的转换。由于每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。

线程是CPU任务调度和执行的最小单位，一个进程中可以包含多个线程，这些线程可以并发运行，且共享进程提供的相同的代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程间切换的开销小。

协程，又称微线程，是一种用户态的轻量级线程，一个线程可以有多个协程。协程的调度完全由用户控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以协程的上下文切换非常快。

线程在进程的内部，它不能独立执行，必须依存于进程中，由进程提供多个线程的执行控制，进程和线程都可以并发的执行。

协程抽象于线程之上，线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行。与线程相比，协程占用资源小，由用户调度，切换开销小，同一个线程中的协程不需要使用锁，执行效率更高。

### 协程

线程也有自己的执行体，记录他们执行入口、id

切换执行体的时候，要先保存当前执行体的执行现场，然后切换到另一个执行体

线程创建的执行体就是协程

给协程分配用户栈

就是用户态线程

os是不知道协程存在的

控制流的主动让出和回复

由用户态调度的多谢线程模型

高并发：用户态调度模型

I/O多路复用中协程·

### I/O多路复用

把一堆需要处理的文件描述符给内核，当其中任何一个文件描述符背后的文件具备读写条件时，就把这些文件描述符挑选出来，给内核处理

一切皆为文件

一套接口操作一切

open()

read()

write()

文件描述符：内核数据结构的索引

fd = accept(...)

read 是阻塞操作

串行效率太低·

![image-20240402132817567](file:///C:/Users/chile/AppData/Roaming/Typora/typora-user-images/image-20240402132817567.png?lastModify=1713069570)

### 进程和线程的区别

### 数组和链表的异同点

### 数组和链表插入和删除的时间复杂度，需要整理吗？

### linux指令

## 4月3日美团一面

### 内存读取的具体过程

### 无锁编程解决CASmalloc